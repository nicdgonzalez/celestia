# 2025-09-18

ðŸ“… Day 1 of **Building a Minecraft Dashboard from Scratch**.

## TLDR

Today, we designed and built a proof-of-concept application. We now have a
back-end server built in Rust, and a front-end client built with Next.js. The
two can communicate with one another via websockets, and the client can now
update the server status (online or offline) instantaneously when it receives
the `SERVER_STATUS_UPDATE` event.

We didn't get to the Minecraft plugin today, but the following `curl` command
does the job:

```bash
curl --verbose --request POST --header 'Content-Type: application/json' --url "http://127.0.0.1:1140/api/status" --data '{"status":"online"}'
```

## Overview

First of all, what is a Dashboard?

A **Minecraft Dashboard** is an application that displays information about our
Minecraft server. It should contain useful data to help us effectively manage
our server.

I feel like there are 2 ways that you can look at this that will also affect
the way we design and develop this project:

1. A dashboard tells us information about a **running** server, which means it
   should only be viewable if the server has been started, or
1. A dashboard allows us to **manage** a server, in which case, it allows us to
   manipulate settings, start/stop the server, etc., which means that it must
   live outside of the Minecraft world and be aware of the state of the server
   at all times.

In my opinion, the latter is slightly more complicated, but also more useful;
this is the one that we will be building starting today. I'm all for
practicality, and I like a good challenge ðŸ¤­

## Planning

Details outlining what we want to make, and how we plan to get there.

### Planned Features

Let's start by coming up with some features we want to include:

- I want to be able to start/stop the server from the dashboard.
- I want to be know who is currently online, and how long they have been online
  for.
- I want to track these metrics (to make better decisions on when to backup or
  update the server).
- I want to know the percentage of resources the server is using, that way I
  know what I can increase/decrease for optimal performance.
- I want to be able to manage plugins and settings directly from the dashboard.
- I want to be able to read from/write to my server console in real-time.

### Tech stack

For the Minecraft server, I will be using the one provided by [PaperMC]. Paper
plugins are written in Java, which I have minimal experience with, so we'll
have to learn it for this project.

For the Dashboard's User Interface (UI), I want it to be in the browser. We
will have to decide on a front-end framework (...or not, we could always just
write raw JavaScript ðŸ‘€), but it depends on how much we want to simplify (or
complicate) our deployment setup.

For working with the file system, e.g., updating configuration settings,
downloading and installing plugins, updating our Minecraft server's version,
etc., I really trust Rust to get the job done well. Which leaves us with the
question...

### Unanswered questions

If I'm writing an HTTP server in Rust, should the UI be compiled and served
from Rust as well? Or should we have a separate front-end server that we can
communicate with?

This is a question I genuinely don't know the answer to, so we'll have to do
some testing to figure out what is the best fit.

I feel there are a few questions I still need answered before we can get
started on writing some actual code:

- Is the Minecraft plugin supposed to be "read only", "write only", or "read
  and write"? Does it send information, do we query it for information, or
  both?

~~If we want to avoid coupling our projects together, I believe making it "read
only" is the better option.~~ We do not want to avoid coupling our servers
because we also need the plugin to let us know when certain events happen
(e.g., when players join or leave). Therefore, we'll need a way to communicate
with the Minecraft server, and I think an HTTP server will probably be the
easiest method.

To summarize, we will be developing a Minecraft plugin that starts an HTTP
server within the Minecraft server, so we can query it for information. The
plugin will also be responsible for letting our Rust server know when a player
has joined or left the server, maybe via a callback/webhook system.

- Should the Rust server be responsible for compiling and serving the front-end
  UI?

We are designing our dashboard to run locally, so whether it deploys two or
three separate web servers makes no real difference (mainly in terms of cost,
something we would have to consider if this was a real, production
application)... so I think for now, we can deploy three separate servers, and
if in the future we find that we can condense it into two with no issues, we
can worry about it then.

Update: After thinking about it a little bit more, I decided it would be best
to deploy the client along with the Rust server, since we'll be using
websockets to communicate, and the server needs to be open first anyway for
that to happen.

Update #2: After thinking about it even more, if the front-end doesn't have a
server of it's own, and it's relying on the Rust server to serve pages, what
happens when you request, for example, `/settings`? Rust doesn't know about
this page, it only exists within the single `index.html` that was generated,
along with some JavaScript at the home path (`/`). I'm not certain about this,
but I would imagine the user would get a 404 error if trying to reach the page
directly, but it would load if clicking the button from `/`? It would require
some testing, but I think deploying a separate server would be best. I'll just
have to be careful about the order that the servers are started... I'll test it
before following through with that decision though.

## Getting started

I think step 1 should be to get a proof-of-concept application running.

Since the front-end needs to know when the Minecraft server turns on, I'm
thinking the client should use a websocket to listen to events. When certain
events trigger, the UI gets updated. We will use a websocket connection to pass
events back and forth between the front and back ends.

Let's start by making all the necessary parts:

- Frontend: A JavaScript web server that will display when the server goes
  online and offline. This will establish a connection with the back-end server
  via websockets.
- Backend: An HTTP server written in Rust that listens for when the Minecraft
  server turns on and sends that information to the front-end client.
- Plugin: A Minecraft plugin written in Java, that sends an HTTP request to the
  back-end server once the Minecraft server is officially online.

From these descriptions, it seems to me like the Rust server needs to be the
one that turns on first, so let's work on that one.

The code for the server can be found in [server](../server).

Then, we create a minimal page for the client, which can be found in
[client](../client).

We didn't get to the Minecraft plugin today, but we have enough to prove it
works. We'll get to the Minecraft plugin tomorrow instead.

## Post-development notes

- We don't have a plugin yet, but we'll get to it soon enough.
- We have no way of linking the Minecraft server to the Dashboard at the
  moment... I'm not sure how we'll ensure that the correct server is updating
  the dashboard, but I would like to implement some sort of protection for
  that.
- I want to think more about the API design, I definitely didn't give it enough
  thought before getting started. Getting it right before coding too much will
  make things easier down the line.
- I want to organize the types/interfaces in TypeScript land a bit better.

Other than that, I think everything has gone pretty smoothly so far.

## Acknowledgements

Shout out to [Jorge Flores] for sharing their #100DaysOfCode challenge, which
in turn inspired me to start this project and document the process.

[jorge flores]: https://www.linkedin.com/in/jorge-flores-53432334b/
[papermc]: https://papermc.io/
